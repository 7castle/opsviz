#!/usr/bin/env python

import argparse
import subprocess
import sys
import os
import boto.cloudformation
import boto.iam
import boto.sts
import boto.s3

import time
from gen_secrets import gen_password
import random
import string

def percent_cb(complete, total):
    """
    Utility function for printing out progress bars with s3 boto
    """

    sys.stdout.write('.')
    sys.stdout.flush()

def get_privkey():
    '''When the -newkey option is given to req, it writes the key
    to a file named "privkey.pem". We want to read the key from
    that file and the clean it up'''
    # this is required to make the java library on the
    # recieving end happy
    privkey = subprocess.check_output([
        'openssl', 'rsa', '-in', 'privkey.pem'])

    try:
        os.unlink('privkey.pem')
    except OSError:
        sys.stderr.write("WARNING: failed to delete privkey.pem\n")

    return privkey

def gen_certificate():
    '''Generates a self-signed cert to be used by
    RabbitMQ'''
    # TODO: provide a way to not have to enter the interactive
    # openssl prompts
    proc = subprocess.Popen(['openssl', 'req', '-new',
                             '-nodes', '-newkey', 'rsa:2048',
                             '-x509'], stdout=subprocess.PIPE)

    if proc.wait() != 0:
        raise SystemExit("Failed to generate self-signed OpenSSL")

    return (get_privkey(), proc.stdout.read())


class KeyValueArgs(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if not hasattr(namespace, self.dest):
            setattr(namespace, self.dest, {})

        key, value = values.split('=')
        getattr(namespace, self.dest)[key] = value

class OpsVizStackCreator(object):
    def __init__(self, args):
        self.args = args
        self.sts  = boto.sts.connect_to_region(args.region)
        self.iam  = boto.iam.connect_to_region(args.region)
        self.s3   = boto.s3.connect_to_region(args.region)
        self.cf   = boto.cloudformation.connect_to_region(args.region)
        self.s3_bucket = None
        self.cert_arn = None
        print "Using boto credentials for IAM account in %s" % self.iam.get_signin_url()

    def get_bucket(self):
        """
        We want to store a few things in S3.  One of them is the cloudformation template itself.
        So, we need to create it outside cloudformation.
        Once it is ready, we can also us the bucket for:
        * logstash configuration files
        * dashboard backups
        * elasticsearch snapshots
        * image assets
        * more?
        """

        # short circuit if we need to
        if self.s3_bucket is not None:
            print "Using bucket:%s in %s" % (self.s3_bucket.name, self.args.region)
            return self.s3_bucket

        # Set the default bucket name
        # create a bit of randomness
        postfix = ''.join(random.choice(string.ascii_lowercase) for _ in range(6))
        # concatenate the parts
        bucket_name = "%s-%s-%s" % ("pythian-ovs", self.args.stack_name, postfix)
        # normalize
        bucket_name = bucket_name.replace(" ", "-").lower()

        # Override the bucket_name if we want to
        if self.args.bucket_name:
            bucket_name = self.args.bucket_name.replace(' ', '-').lower()
            if bucket_name != self.args.bucket_name:
                print "Normalizing the bucket name from %s to %s" % (
                    self.args.bucket_name,
                    bucket_name
                )

        # Create the bucket if we need to
        for bucket in self.s3.get_all_buckets():
            if bucket.name == self.args.bucket_name:
                self.s3_bucket = bucket
        if self.s3_bucket is None:
            self.s3_bucket = self.s3.create_bucket(bucket_name)
        print "Using bucket:%s in %s" % (self.s3_bucket.name, self.args.region)
        return self.s3_bucket

    def upload_cloudformation(self):
        cloudformation_json_key = 'cloudformation/pov_stack.json'
        s3_key = boto.s3.key.Key(self.get_bucket(), cloudformation_json_key)

        print "Uploading Cloudformation Json to %s" % cloudformation_json_key,
        s3_key.set_contents_from_filename("cloudformation.json",
                                          cb=percent_cb, num_cb=10)
        #with open('cloudformation.json') as f:
            #s3_key.send_file(f)
        print "Done"
        self.args.template_url = s3_key.generate_url(600)
        #print self.args.template_url

    def upload_cert(self):
        '''Uploads a cert and key to IAM and return the ARN of the
        uploaded cert'''

        resp = self.iam.upload_server_cert(
            cert_name="{}_cert".format(self.args.stack_name),
            cert_body=self.ssl_cert,
            private_key=self.ssl_key)

        try:
            return resp['upload_server_certificate_response']['upload_server_certificate_result']['server_certificate_metadata']['arn']
        except KeyError:
            raise SystemExit("Failed to get ARN from cert upload. Resp: {}".format(resp))

    def prepare_cert(self):
        certs_response = self.iam.list_server_certs()
        cert_list = certs_response[u'list_server_certificates_response'][u'list_server_certificates_result'][u'server_certificate_metadata_list']
        print cert_list
        valid_certs = [x for x in cert_list if x[u'server_certificate_name'] == "{}_cert".format(self.args.stack_name)]
        if len(valid_certs) == 1:
            self.cert_arn = valid_certs[0][u'arn']
        else:
            self.ssl_key, self.ssl_cert = gen_certificate()
            self.cert_arn = self.upload_cert()

        return self.cert_arn

    def gen_cf_params(self):
        params = {
            'RabbitMQSensuPassword': gen_password(),
            'RabbitMQStatsdPassword': gen_password(),
            'RabbitMQLogstashExternalPassword': gen_password(),
            'RabbitMQLogstashInternalPassword': gen_password(),
            'GrafanaDBPassword': gen_password(),
            'RabbitMQErlangCookie': gen_password(50),
            'RabbitMQCertificateARN': self.cert_arn,
            'DoormanSessionSecret': gen_password(50)
        }

        #user provided params override whatever we generate or set
        #as a default
        params.update(self.args.params)

        return params

    def read_template(self):
        with open('cloudformation.json', 'r') as filehandle:
            return filehandle.read()

    def spin_up(self, params):
        print "Creating stack with params: "
        print params
        if self.args.use_bucket:
            self.upload_cloudformation()

        create_stack_kwargs = {
            'stack_name': self.args.stack_name,
            'capabilities': ['CAPABILITY_IAM'],
            'parameters': params.items(),
            'disable_rollback': True
        }
        if not self.args.template_url:
            create_stack_kwargs['template_body'] = self.read_template()
        else:
            create_stack_kwargs['template_url'] = self.args.template_url

        stack_id = self.cf.create_stack(**create_stack_kwargs)

        #events we have already printed out
        reported_events = set()
        stack = self.cf.describe_stacks(stack_id)[0]

        while stack.stack_status == 'CREATE_IN_PROGRESS':
            all_events = set(stack.describe_events())
            for event in reported_events - all_events:
                print event

            reported_events = all_events
            time.sleep(5)
            stack.update()

        if not stack.stack_status == 'CREATE_COMPLETE':
            raise SystemExit("Stack creation failed")
        else:
            print "Stack creation completed"

    def create_stack(self):
        self.prepare_cert()
        self.spin_up(self.gen_cf_params())

def get_args():
    parser = argparse.ArgumentParser(description='Create an OpsViz stack')
    parser.add_argument('--region', default='us-east-1',
                        help='AWS region. Default: us-east-1')
    parser.add_argument('stack_name',
                        help='CloudFormation stack name. Must be unique')
    parser.add_argument('--dry-run', action='store_true',
                        help='Generate params and display them,' +
                        'but does not spin up the stack')
    parser.add_argument('--cookbook-repo', '-c',
                        help="The git url for your custom cookbooks")
    parser.add_argument('--template-url', '-t',
                        help="The s3 url for your template")
    parser.add_argument('--param', dest='params', action=KeyValueArgs,
                        default={},
                        help="Override additional params in the form of key=value. Can be specified multiple times")
    parser.add_argument('--bucket-name', '-b',
                        help="Override the default name of the s3 bucket for your stack (for storing the cloudformation template and configs)")
    parser.add_argument('--use-bucket', dest='use_bucket', action='store_true')
    parser.add_argument('--no-use-bucket', dest='use_bucket', action='store_false')
    parser.set_defaults(use_bucket=True)

    args = parser.parse_args()

    if not args.cookbook_repo:
        raise SystemExit("A cookbook repo is required")

    if not args.stack_name:
        raise SystemExit("A stack name is required")

    #Add the cookbook to the list of user params. The cookbook
    #is only provided stand-alone because it is required
    args.params['CookbooksRepo'] = args.cookbook_repo

    return args

def main():
    args = get_args()
    stack_creator = OpsVizStackCreator(args)
    stack_creator.create_stack()

if __name__ == '__main__':
    main()
